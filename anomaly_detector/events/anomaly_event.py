from ..types.anomaly_status import Anomaly_Status
from ..exception.exceptions import factStoreEnvVarNotSetException
import requests


class AnomalyEvent:
    def __init__(self, predict_id, message, score, anomaly_status, fact_evt_url):
        """
        Anomaly Events communicates with the fact-store to get
        query metadata about machine learning anomaly be flagged
        by users as false.
        This service prevents the anomalies from triggering
        emails to end users.

        The following are required parameters.

        :param predict_id:
        :param message:
        :param score:
        :param anomaly_status:
        :param config:
        """
        if fact_evt_url == "" or fact_evt_url is None:
            raise factStoreEnvVarNotSetException()

        self.predict_id = str(predict_id)
        self.message = message
        self.score = score
        self.anomaly_status = anomaly_status
        self.FACT_STORE_URL = fact_evt_url

    def isEvtFalseAnomaly(self):
        """
        Process Anomaly Event

        Stores anomaly into factstore and validates if this anomaly
        was previous reported as false.
        It will also return a message with  for example 'status: false'
        Also this

        :param predict_id: This id is autogenerated and used
         to track events of anomaly.
        :param message: the message that was processed via
        logs stream
        :param score: calculated via machine learning algorithm
        :param anomaly_status: when the score is greater then
        the threshold.
        :return: will return 1 if it was a true anomaly.
        0 if it was a false anomaly.
        """
        # When fact-store is not set we can assume the user
        # doesn't want to check
        # FactStore for false anomalies.
        # And just wants what the algorithm predicts

        r = requests.post(url=self.FACT_STORE_URL, json=self.to_dict())
        data = r.json()
        print(
            "Recording anomaly-event: {} {} {} {}".format(
                str(self.predict_id), self.message, self.score, self.anomaly_status
            )
        )
        print("data['false_anomaly'] is {} ".format(data["false_anomaly"]))
        # TODO: You should throw an exception
        #  if you get a value that other then 'false' or 'true'

        if data["false_anomaly"] is False:
            return Anomaly_Status.FALSE.value
        else:
            return Anomaly_Status.CORRECT.value

    def to_dict(self):
        """ Returns a dictionary of properties"""
        return {
            "predict_id": self.predict_id,
            "message": self.message,
            "score": self.score,
            "anomaly_status": self.anomaly_status,
        }
